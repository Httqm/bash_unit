#!/bin/bash

assertFailWithStatus() {
  #deprecated: use assert_status_code instead
  assert_status_code "$@"
}

assertEquals() {
  #deprecated: use ssert_equals instead
  assert_equals "$@"
}

assertFail() {
  #deprecated: use assert_fail instead
  assert_fail "$@"
}

fail() {
  local MESSAGE=$1
  printf "FAILURE:\n$MESSAGE\n"
  print_stack | grep -v ^$BASH_SOURCE
  exit 1
}

assert() {
  local assertion=$1
  local message=$2
  local tmp_file=/tmp/$$.assert.stderr
  eval "($assertion)" >/dev/null 2>$tmp_file || \
    (cat $tmp_file; rm $tmp_file; fail "$message")
}

assert_fail() {
  local assertion=$1
  local message=$2
  eval "($assertion)" >/dev/null 2>&1 && fail "$message" || true
}

assert_status_code() {
  local expected_status=$1
  local assertion="$2"
  local message="$3"
  local status
  eval "($assertion)" >/dev/null 2>&1 && status=$? || status=$?
  assert_equals $expected_status $status "$message"
}

assert_equals() {
  local expected=$1
  local actual=$2
  local message=$3
  
  [ "$expected" = "$actual" ] || \
    fail "$message\nexpected [$expected] but was [$actual]"
}

fake() {
  local command=$1
  shift
  if [ $# -gt 0 ]
  then
    eval "function $command() { export FAKE_PARAMS=\"\$@\" ; $@ ; }"
  else
    eval "function $command() { echo \"$(cat)\" ; }"
  fi
  export -f $command
}

run_test_suite() {
  set -e
  for test in $(set | grep  -E '^test.* ()' | sed -e 's: .*::')
  do
    declare -F | grep ' setup$' >/dev/null && setup
    (run $test)
  done
}

print_stack() {
  local i=1
  while ! [ -z ${BASH_SOURCE[$i]} ]
  do
    echo ${BASH_SOURCE[$i]}:${FUNCNAME[$i]}\(\):${BASH_LINENO[$((i-1))]}
    i=$(($i + 1))
  done
}

run() {
    TEST=$1
    echo -n "Running test $TEST... "
    $TEST
    echo "SUCCESS"
}

#run tests received as parameters

for test in "$@"
do
  echo "Running tests in $test"
  (source "$test"; run_test_suite)
done
