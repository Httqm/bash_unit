#!/bin/bash
#
#   bash unit testing enterprise edition framework for professionals
#   Copyright (C) 2011-2016 Pascal Grange
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 3 of the License, or
#   (at your option) any later version.
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software Foundation,
#   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
#
#  https://github.com/pgrange/bash_unit

ESCAPE=$(printf "\033")
NOCOLOR="${ESCAPE}[0m"
RED="${ESCAPE}[91m"
GREEN="${ESCAPE}[92m"
YELLOW="${ESCAPE}[93m"
BLUE="${ESCAPE}[94m"

# All tests informations must be sent to the following three
# file descriptors:
# LOG -> all test logs, such as SUCCESS, FAILURE, stacktrace...
# OUT -> all code under test outputs relevant in the context
# ERR -> all code under test error outputs relevant in the context
exec {LOG}>&1
exec {STACK}>&1
exec {OUT}>&1
exec {ERR}>&1

fail() {
  local message=$1
  local stdout=$2
  local stderr=$3

  notify_test_failed $__bash_unit_current_test__ "$message"
  [[ ! -z $stdout ]] && [ -s $stdout ] && cat $stdout | notify_stdout
  [[ ! -z $stderr ]] && [ -s $stderr ] && cat $stderr | notify_stderr

  print_stack | grep -v ^$BASH_SOURCE | notify_stack
  exit 1
}

assert() {
  local assertion=$1
  local message=$2

  _assert_expression \
    "$assertion" \
    "[ \$status == 0 ]" \
    "\"$message\""
}

assert_fail() {
  local assertion=$1
  local message=$2

  _assert_expression \
    "$assertion" \
    "[ \$status != 0 ]" \
    "\"$message\""
}

assert_status_code() {
  local expected_status=$1
  local assertion="$2"
  local message="$3"

  _assert_expression \
    "$assertion" \
    "[ \$status == $expected_status ]" \
    "\"$message\" expected status code $expected_status but was \$status"
}

_assert_expression() {
  local assertion=$1
  local condition=$2
  local message=$3
  (
    local stdout=$(mktemp)
    local stderr=$(mktemp)
    trap "rm  -f $stdout $stderr" EXIT

    local status
    eval "($assertion)" >$stdout 2>$stderr && status=$? || status=$?
    if ! eval $condition
    then
      fail "$(eval echo $message)" $stdout $stderr
    fi
  ) || exit $?
}

assert_equals() {
  local expected=$1
  local actual=$2
  local message=$3
  [[ -z $message ]] || message="$message\n"
  
  if [ "$expected" != "$actual" ]
  then
    fail "$message expected [$expected] but was [$actual]"
  fi
}

assert_not_equals() {
  local unexpected=$1
  local actual=$2
  local message=$3
  [[ -z $message ]] || message="$message\n"

  [ "$unexpected" != "$actual" ] || \
    fail "$message expected different value than [$unexpected] but was the same"
}

fake() {
  local command=$1
  shift
  if [ $# -gt 0 ]
  then
    eval "function $command() { export FAKE_PARAMS=\"\$@\" ; $@ ; }"
  else
    eval "function $command() { echo \"$(cat)\" ; }"
  fi
  export -f $command
}

run_test_suite() {
  local failure=0
  for test in $(set | grep  -E '^test.* ()' | grep -E "$test_pattern" | sed -e 's: .*::')
  do
    (
      local status=0
      declare -F | grep ' setup$' >/dev/null && setup
      (__bash_unit_current_test__="$test" run_test) || status=$?
      declare -F | grep ' teardown$' >/dev/null && teardown
      exit $status
    )
    failure=$(( $? || $failure))
  done
  return $failure
}

run_test() {
  set -e
  notify_test_starting "$__bash_unit_current_test__"
  $__bash_unit_current_test__ && notify_test_succeeded "$__bash_unit_current_test__"
}

usage() {
  echo "$1" >&2
  echo "$0 [-f <output format<] [-p <pattern1>] [-p <pattern2>]... <test_file1> <test_file2>..." >&2
  echo >&2
  echo "Runs tests in test files that match <pattern>s" >&2
  echo "<output format> is optionnal only supported value is tap" >&2
  echo "See https://github.com/pgrange/bash_unit" >&2
  exit 1
}

# Formating

print_stack() {
  local i=1
  while ! [ -z ${BASH_SOURCE[$i]} ]
  do
    echo ${BASH_SOURCE[$i]}:${BASH_LINENO[$((i-1))]}:${FUNCNAME[$i]}\(\)
    i=$(($i + 1))
  done
}

format() {
  local color=$1
  shift
  if [ -t 1 ] ; then echo -en "$color" ; fi
  if [ $# -gt 0 ]
  then
    echo $*
  else
    cat
  fi
  if [ -t 1 ] ; then echo -en "$NOCOLOR" ; fi
}

notify_suite_starting() {
  test_file="$1"
  echo "Running tests in $test_file" >&$LOG
}

notify_test_starting() {
  local test="$1"
  echo -n "Running $test... " | format "$BLUE" >&$LOG
}

notify_test_succeeded() {
  format "$GREEN" "SUCCESS" >&$LOG
}

notify_test_failed() {
  local message="$2"
  format "$RED" "FAILURE" >&$LOG
  [[ -z $message  ]] || printf -- "$message\n" >&$LOG
}

notify_stdout() {
  sed 's:^:out> :' | format $GREEN >&$OUT
}

notify_stderr() {
  sed 's:^:err> :' | format $RED   >&$ERR
}

notify_stack() {
  format "$YELLOW" >&$STACK
}

tap_notify_suite_starting() {
  test_file="$1"
  echo "# Running tests in $test_file" >&$LOG
}

tap_notify_test_starting() {
  echo -n
}

tap_notify_test_succeeded() {
  local test="$1"
  echo -n "ok" | format "$GREEN" >&$LOG
  echo -n ' - ' >&$LOG
  echo "$test" | format "$BLUE" >&$LOG
}

tap_notify_test_failed() {
  local test="$1"
  local message="$2"
  echo -n "not ok" | format "$RED" >&$LOG
  echo -n " - " >&$LOG
  echo "$test" >&$LOG
  [[ -z $message  ]] || printf -- "$message\n" | sed -u -e 's/^/# /' >&$LOG
}

tap_notify_stdout() {
  sed 's:^:# out> :' | format $GREEN >&$OUT
}

tap_notify_stderr() {
  sed 's:^:# err> :' | format $RED   >&$ERR
}

tap_notify_stack() {
  sed 's:^:# :' | format "$YELLOW"   >&$STACK
}

output_format=default
test_pattern=""
separator=""
while getopts "p:f:" option
do
  case "$option" in
    p)
      test_pattern="${test_pattern}${separator}${OPTARG}"
      separator="|"
      ;;
    f)
      output_format="${OPTARG}"
      ;;
    ?|:)
      usage
      ;;
  esac
done
shift $((OPTIND-1))

#check test files exist and is readable
for test_file in "$@"
do
  test -e $test_file || usage "file does not exist: $test_file"
  test -r $test_file || usage "can not read file: $test_file"
done

#set output format
case "$output_format" in
  default)
    ;;
  tap)
    notify_suite_starting() { tap_notify_suite_starting "$@" ; }
    notify_test_starting()  { tap_notify_test_starting  "$@" ; }
    notify_test_succeeded() { tap_notify_test_succeeded "$@" ; }
    notify_test_failed()    { tap_notify_test_failed    "$@" ; }
    notify_stdout()         { tap_notify_stdout         "$@" ; }
    notify_stderr()         { tap_notify_stderr         "$@" ; }
    notify_stack()          { tap_notify_stack          "$@" ; }
    ;;
  *)
    usage "unsupproted output format: $output_format"
    ;;
esac

#run tests received as parameters
failure=0
for test_file in "$@"
do
  notify_suite_starting "$test_file"
  (
    source "$test_file"
    cd $(dirname "$test_file")
    run_test_suite
  )
  failure=$(( $? || $failure))
done
exit $failure
